


**Rules of "Score"**

Four dice are rolled. The default die are two six-sided, one twelve-sided, and one twenty-sided die. The goal is to make the number "20" in two or three steps using addition, subtraction, multiplication, division, and/or concatenation.

If a player calls out "Score!", or clicks "SCORE" in the computer version, he or she must quickly demonstrate how to make the number "20". Failure to do so loses the player one point; success gains a point. Clicking "SCORE" starts a countdown which currently allows 30 secondes, which is more than enough time. 

If a player clicks "IMPOSSIBLE", a 60-second countdown begins. If no player clicks "SCORE" during the 60 seconds, the player who clicked "IMPOSSIBLE" gains one point. If a player clicks "SCORE" during the countdown and succeeds in making "20" within 30 seconds, the player who clicked "IMPOSSIBLE" loses two points. It is possible for the player who clicked "IMPOSSIBLE" to also click "SCORE". Making the number "20" within 30 seconds gains back one of the two points lost because the 60 second countdown was successfully interrupted.

In order to gain a point by making the number "20", a player must use a number generated by a previous computation. Those number have the color red.

The flow of this application can best be understood by following the message prefixes.

First, CC#$42 is sent from the login form.
The server intercepts CC#$42 and, if the name is in the proper format and hasn't been taken, the server responds by adding the new user to the state MVar, broadcasting an announcement to the chat section of participating browsers, and broadcasting the new state reduced to Text. The server broadcases the server state with the prefix "CB#$42". The browsers intercept messages with that prefix, preventing them from cluttering the chat message section, and sending them to the player-score displays in the connected browsers. Whenever a player disconnects, joins, or has a change in score, the game state (in Text format) is broadcast.

Here is how the game state is defined:

```haskell
type Name = Text
type Score = Int
type Client = (Name, Score, WS.Connection)
type ServerState = [Client]

newServerState :: ServerState
newServerState = []
```

The game state is placed in an MVar as follows:

```haskell
main = do
    state <- newMVar newServerState
... 
```
State is modified during game play by removing state from the MVar and replacing it with the modified version. For example, the following code increases a player's score:

```haskell
incFunc :: Text -> Client -> Client
incFunc x (a, b, c)   | x == a   = (a, b + 1, c)
                      | otherwise = (a, b, c)
                      
upScore :: Text -> ServerState -> ServerState 
upScore name = map (incFunc name)
```
Here is the browser code dealing with the three prefixes mentioned so far:
```javascript
function onMessage(event) {
    var impossibleClicker = players.getImpossibleClicker();
    var player = players.getPlayer();
    var scoreClicker = players.getScoreClicker();
    var privateClicker = players.getPrivateClicker();
    var gameArray = event.data.split(",");
    var d2 = event.data.substring(0,6);
    var d3 = event.data.substring(2,6);
    var source = gameArray[1];  // Value of sender's privateClicker
    var sender = gameArray[2];
    var extra = gameArray[3];
    var p = $(document.createElement('p')).text(event.data); 
    if (player === sender || privateClicker !== "a@F$Uy&private" &&  source !== "a@F$Uy&private") {
        switch (d2) {
            case "CA#$42":     // Set up the next round of play.
                refresh(); 
                $("#impossibleJ").show();
                $("#scoreF").show();
                $("#info1").html("");
                $(".erase").show();
                $("#show").show();
                $("#show2").show();
                $("#solutions").show();
                $("#iutions2").show();
                $("#a0").html("");
                var auu = gameArray[3]
                var buu = gameArray[4]
                var cuu = gameArray[5]
                var duu = gameArray[6]
                rollText = auu + "," + buu + "," + cuu + "," + duu + "," + 42;
                players.setRollText(rollText) 
                .setD(-1);
                console.log("Here is rollText: " + rollText); 
                populate(auu,buu,cuu,duu);
                $("#a4").html(auu + " &nbsp; " + buu + " &nbsp; " + cuu + " &nbsp; " + duu);
            break;

            case "CB#$42":
                $("#users").html(event.data.substring(6));
            break;

            case "CC#$42":
                return;
            break;
```
Messages with the "CB#$42" pefix go to the socoreboard div with id "user", and messages prefixed by "CC#$42", the new player prefix, are discarded to prevent cluttering the chat message section.

The meanings and uses of the variables at the start of function "onmessage" will be explained later. For now, I will explain only the code which screens who gets into the the switch routine, namely:

```javascript
if (player === sender || privateClicker !== "a@F$Uy&private" &&  source !== "a@F$Uy&private")
```

There are two modes of play in #Score#: group play and individual play. When one group player rolls the dice, all group players see the roll, but individual players do not. When an individual player rolls the dice, no other player sees it. "player \=\== sender" lets individual players in, along with one group player but that is of no consequence since the next test covers all group players. "a@F$Uy&private" is the default value for new players. It signifies that they are in individual play mode. If a player clicks "GO MULTIPLAYER", the value of privateClicker becomes the player's login name. So "privateClicker !\== 'a@F$Uy&private' means the player has gone public. "sender !== 'a@F$Uy&private' means a group player sent the message. All group players should receive all messages sent by other group players, and the second test makes sure this happens.

