{"name":"Score2","tagline":"Haskell websockets up and running.","body":"##The Game of Score\r\n####*An extension of github.com/jaspervdj/websockets as implemented by yesodweb/wai/wai-websockets*\r\n\r\n####Rules of \"Score\"\r\n\r\nFour dice are rolled. The default die are two six-sided, one twelve-sided, and one twenty-sided die. As mentioned above, the goal is to make the number \"20\" in two or three steps using addition, subtraction, multiplication, division, and/or concatenation.\r\n\r\nIf a player calls out \"Score!\", or clicks \"SCORE\" in the computer version, he or she must quickly demonstrate how to make the number \"20\". Failure to do so loses the player one point; success gains a point. Clicking \"SCORE\" starts a countdown which currently allows 30 seconds, which is more than enough time.\r\n\r\nIf a player clicks \"IMPOSSIBLE\", a 60-second countdown begins. If no player clicks \"SCORE\" during the 60 seconds, the player who clicked \"IMPOSSIBLE\" gains one point. If a player clicks \"SCORE\" during the countdown and succeeds in making \"20\" within 30 seconds, the player who clicked \"IMPOSSIBLE\" loses two points. It is possible for the player who clicked \"IMPOSSIBLE\" to also click \"SCORE\". Making the number \"20\" within 30 seconds gains back one of the two points lost because the 60 second countdown was successfully interrupted.\r\n\r\nIn order to gain a point by making the number \"20\", a player must use a number generated by a previous computation. Numbers generated during game play are colored red.\r\n\r\nPlayers who click \"GO MULTIPLAYER\" are in competition with one another. They can click \"GO PRIVATE\" to return to private play.\r\n\r\nStudents are encouraged to look for mistakes in the computer generated lists of solutions. Does 15-(-5)=20 look right?. What about 2+(3*(4/(2/3)))=20?\r\n###How The Game Was Developed\r\nby David Schalk\r\n\r\nI started with the chat example at github.com/wai/wai-websockets. It is Jasper Van der Jeugt 's websockets adapted to the warp web server. The routine work of the chat server is receiving messages from individual browsers and broadcasting them to all participants. It also parses sign-in messages to make sure the format is correct and there are no duplicate user names. The server keeps a list of participants in a Haskelll programming language MVar, and replaces the list with an updated version whenever there is a disconnect or a sign-in.\r\n\r\nI modified the participant list to include scores along with names. Whenever the list is replaced due to a score change, sign-in, or disconnect, the server sends a line of text interspersed with 'br' in brackets and the prefix 'CB#$42'. The browsers intercept these messages and divert them away from the chat message section and into the scoreboard. There are fifteen six-character message prefixes in the format 'Cx#42' where 'x' is some capital letter. None of these go into the chat message section. They contain data and instructions for the game. Application messages are either Javascript strings or Haskell Text. Browsers split comma-separated strings into arrays and distribute the elements according to the their six-character prefixes (element '0' in the arrays).\r\n\r\nIt would be nice if players could compete in small groups in discreet chat rooms, or even play solitaire in their own room. Solitaire play is currently an option, but the chat messages and scoreboard are communal. I am also thinking of providing the option of changing the dice from 6, 6, 12, and 20 sided to whatever the players choose. The goal in 'Score' is to make the number '20' out of four random numbers in two or three stages using addition, subtraction, multiplication, division, and concatenation. The goal of '20' could be made adjustable along with the maximum sizes of the four random integers. Suggestions are very welcome.\r\n\r\n####Initiation Stage\r\n\r\nThe game interface in the browsers responds to text messages transmitted by the server. Javascript interprets these as strings, and the strings it sends become text before they are used in the server application. Chat messages sent to the server and are broadcast to all participating browsers. Messages intended for game control are prefixed by C\\_#$42 where \"\\_\" is a capital letter. Messages received by browsers which are for game control, and which usually carry data, also have the C _#$42 prefixes. The flow of the game can be understood by tracing the routes of the prefixed messages.\r\n\r\nA player joins the game by entering a name in a form. Here is the Javascript form code:\r\n\r\n```Javascript\r\n$('#join-form').submit(function () {\r\n    $('#warnings').html('');\r\n    var user = $('#user').val();\r\n    players.setPlayer(user);\r\n    ws = createWebSocket('/');\r\n    ws.onopen = function() {\r\n        ws.send(\"CC#$42\" + user);\r\n    };\r\n}\r\n```\r\n\r\nThe server parses the message prefixed by CC#\\$42 and, if the name is in the proper format and hasn't already been taken, the server (1) replaces ServerState list of Clients in the state MVar with with a ServerState list which includes the new player, (2) broadcasts an announcement for placement in the chat section of participating browsers, [3] broadcasts the updated state information for placement in the scoreboard section: and (4) sends the message \"CC#$42\" to the new player. The new state information is sent with the prefix \"CB#$42\", which instructs the browsers to put the updated state information where it belongs. Anytime a new ServerState is created in the server, a message prefixed by CB#$42 and containing the new state information is broadcast to all participating players, keeping scoreboards syncronized with the servers ServerState Client list.\r\n\r\nThe sign-in form sends a message prefixed by CC#$42 to the server and, if everything is in order, the server responds with\r\n\r\n```haskell\r\nliftIO $ modifyMVar_ state $ \\s -> do\r\n    let s' = addClient client s  \r\n    WS.sendTextData conn $ T.pack \"CC#$42\"\r\n    broadcast (getName client `mappend` \" joined\") s'\r\n    broadcast (\"CB#$42\" `mappend` T.concat(intersperse (T.pack \"<br>\") (map tr s'))) s'\r\n    return s'\r\n```\r\nThe message prefixed by \"CB#$42\" is processed in the browsers as follows:\r\n\r\n```javascript\r\ncase \"CB#$42\":\r\n  $(\"#users\").html(event.data.substring(6));\r\nbreak;\r\n```\r\nThe browsers do not need to process the message because the server interspersed 'br' (in HTML brackets) into the state data text it sent so the browser receives it as a string of HTML. The text 'CC#42' is received a a six-character string, prompting a response as follows:\r\n\r\n```javascript\r\n    $('#join-form').submit(function () {\r\n        $('#warnings').html('');\r\n        var user = $('#user').val();\r\n        DS_ob.player = user;\r\n        ws = createWebSocket('/');\r\n        ws.onopen = function() {\r\n            ws.send(\"CC#$42\" + user);\r\n        };\r\n        ws.onmessage = function(event) {\r\n            if(event.data === \"CC#$42\") {\r\n                DS_ob.d = -1;\r\n                createDom();\r\n                createOperators();\r\n                createDropboxes();\r\n                $('.drag').draggable({ revert: \"invalid\", zIndex: 2 });\r\n                $('.dragNew').draggable({ revert: \"invalid\", zIndex: 2 });\r\n                $('.drag2').draggable({ helper: \"clone\", revert: \"invalid\", zIndex: 2 });\r\n                createDrop1();\r\n                createDrop2();\r\n                $(\"#result1\").hide();\r\n                $(\"#result2\").hide();\r\n                $(\"#result3\").hide();\r\n                $(\"#b0\").show();\r\n                $(\"#experiment\").show();\r\n                $(\"#public\").show();\r\n                $(\"#b0\").html(\"Solitaire mode. Click above to enable competition.\")\r\n                $(\"#rollA\").show();\r\n                $(\"#a1\").show();\r\n                $('#join-section').hide();\r\n                $('#chat-section').show();\r\n                $('#users-section').show();\r\n                $(\"#messages\").show();\r\n                $(\".dropx\").hide();\r\n                $(\".drop2x\").hide();\r\n                ws.onmessage = onMessage;\r\n                $('#message-form').submit(function () {\r\n                    var text = $('#text').val();\r\n                    ws.send(text);\r\n                    $('#text').val('');\r\n                    return false;\r\n                });\r\n            } else {\r\n                console.log(\"What?\");\r\n                $('#warnings').append(event.data);\r\n                ws.close();\r\n                delete $('#join-form');\r\n            }\r\n        };\r\n\r\n        $('#join').append('Connecting...');\r\n\r\n        return false;\r\n    });\r\n    $('#join-form').destroy();\r\n});\r\n```\r\nAfter it initiates the player interface, 'ws.onmessage = onMessage' de-references the anonymous function and re-assignes the variable 'ws.onmessage' to onMessage. The entire 'join-form' section becomes eligible for garbage collection after the final line,' delete $('#join-form');'.\r\n\r\nWhen current players receive \"CC#$42\" prefixed messages from new sign-ins, they do not make it to the chat message section. They hit a dead end in the 'onMessage' section pursuant to the following 'do nothing' code:\r\n\r\n```javascript\r\ncase \"CC#$42\":\r\n// Prevents new player login data from defaulting to a chat message.\r\nbreak;\r\n```\r\n\r\n####State And Its MVar\r\n\r\nI have mentioned a ServerState list of clients and an MVar that holds the current state of the game. Here is how that game state is defined:\r\n\r\n```haskell\r\ntype Name = Text\r\ntype Score = Int\r\ntype Client = (Name, Score, WS.Connection)\r\ntype ServerState = [Client]\r\n\r\nnewServerState :: ServerState\r\nnewServerState = []\r\n```\r\nThe game state is placed in an MVar as follows:\r\n\r\n```haskell\r\nmain = do\r\n    state <- newMVar newServerState\r\n```\r\n\r\nState is modified during game play by replacing the ServerState list of Clients in the MVar. For example, the following code increases a player's score:\r\n\r\n```haskell\r\nincFunc :: Text -> Client -> Client\r\nincFunc x (a, b, c)   | x == a   = (a, b + 1, c)\r\n                      | otherwise = (a, b, c)\r\n\r\nupScore :: Text -> ServerState -> ServerState\r\nupScore name = map (incFunc name)\r\n\r\n. . .\r\n\r\nelse if \"CG#$42\" `T.isPrefixOf` msg\r\n    then\r\n    mask_ $ do  \r\n        old <- takeMVar state\r\n        let new = upScore sender old\r\n        putMVar state new\r\n        broadcast msg new\r\n        broadcast (\"CB#$42\" `mappend` T.concat (intersperse \"<br>\" (map tr new))) new\r\n\r\n```\r\nThe 'msg' being broadcast is just the unaltered message that was received, prefixed by 'CG#$42' and containing the sender's name, among other things. The 'CB#$42' prefixed message updates the browser scoreboards.\r\n\r\n####Digession On Immutable Data\r\n\r\n\r\nI played around with some functional javascript libraries that take pains to avoid mutating Javascript variables. Most of the score2 variables are contained in the DS_ob object. I could use getters that delete DS_ob elements and setters that replace them, much like replacing the state list in the server MVar, but what would be the point? It seems to me that, at the cost of some unnecessary overhead, I would end up with precisely the same thing I get with 'DS_ob.element = \"new value\" '. I could re-define DS_ob as a monad, but composability and the other monad features would be useless baggage in score2.\r\n\r\nThe state MVar gets defined once and only its contents change as the game goes on. The same is true of DS_ob.\r\n\r\nHere is the defining code:\r\n\r\n```javascript\r\nfunction makeDS_ob() {\r\n    this.t = -1,\r\n    this.privateClicker = \"a@F$Uy&private\";\r\n    this.player = \"Happy Clown\";\r\n    this.impossibleClicker = \"Adrien Apple\";\r\n    this.scoreClicker = \"Beaming Banana\" ;\r\n    this.rollText = \"1,1,1,1,42\"\r\n    this.d = -1;\r\n    this.ar = [];\r\n    this.bool = [];\r\n    this.game = \"off\";\r\n    this.scoreFunc = function() {\r\n        $(\"#countdown\").html(\"\");\r\n        $(\"#a0\").html(\"\");\r\n        if (this.player === this.scoreClicker) {\r\n            ws.send(\"CL#$42,\" + this.privateClicker + \",\" + this.player + \",\" + \"dummy\");\r\n        }\r\n        if ( this.player === this.impossibleClicker) {\r\n            ws.send(\"CM#$42,\"+ this.privateClicker + \",\" + this.player + \",\" + \"dummy\");\r\n            $(\"#stop60\").triggerHandler('click');\r\n        }\r\n    }\r\n}\r\nvar DS_ob = new makeDS_ob();\r\n```\r\n\r\nThe use of new in the last line sets the context of DS_ob in concrete, but that isn't necessary. It would have sufficed to just define DS_ob as a simple object rather than the result of invoking a constructor. Wrapping the game variables in a closure wouldn't serve any useful purpose. I don't know if any of the alternatives tends to promote more reliable performance in any of the popular browsers.\r\n\r\n**Screening Massages Arriving At The Browsers**\r\n\r\nThe first stage of processing messages coming into the browsers is as follows:\r\n\r\n```javascript\r\nfunction onMessage(event) {\r\n  var game = DS_ob.game;\r\n  var impX = DS_ob.impossibleClicker;\r\n  var plX = DS_ob.player;\r\n  var scX = DS_ob.scoreClicker;\r\n  var prX = DS_ob.privateClicker;\r\n  var gameArray = event.data.split(\",\");\r\n  var d2 = event.data.substring(0,6);\r\n  var d3 = event.data.substring(2,6);\r\n  var sourceStatus = gameArray[1];  // Value of sender's privateClicker\r\n  var sender = gameArray[2];\r\n  var extra = gameArray[3];\r\n  var ext4= gameArray[4];\r\n  var ext5 = gameArray[5];\r\n  var ext6 = gameArray[6];\r\n  var ext7 = gameArray[7];\r\n  var ext8 = gameArray[8];\r\n  var p = $(document.createElement('p')).text(event.data);\r\n  if (plX === sender || prX !== \"a@F$Uy&private\" &&  sourceStatus !== \"a@F$Uy&private\") {\r\n    switch (d2) {\r\n\r\n```\r\nOther than chat messages and the scoreboard update, each message is sent to the server begining with a six-digit prefix, the status (solitaire or group play) of the sender, and the name of the sender, all separated by commas. The server broadcasts messages with these same three preliminary items intact so, after splitting into 'gameArray', gameArray[0] is the six-character prefix, gameArray[1] is the sender's status, and gameArray[2] is the sender's name. The game status, prefixed by 'CB#$42', is sent without commas so instead of d2 = gamearray[0], we have 'd2 = event.data.substring(0,6)'. The test in the 'if' statement returns 'true' if the sender is the receiver of the prefix, or if the sender and receiver are both involved in group play. 'a@F$Uy&private' is the default status; i.e., private. When a player opts for group play, status is set equal to the player's name. This information is kept in the 'DS_ob' object.\r\n\r\n*To be continued*\r\n\r\n##APPENDIX\r\n\r\n**IMPOSSIBLES**\r\n\r\nThe essence of the Score calculation algorythm in the module Fm is contained in the \"impossibles.hs\" file. Fm has much formatting code, which is a distraction when evaluating the algorythm.\r\n\r\nimpossibles.hs computes all dice combinations which cannot be made into the number \"20\" in two or three stages. In 1.5 seconds, it finds all 104 such combinations using a list comprehension on the seven list comprehensions which cover all possible computations. The five operations are defined as follows:\r\n\r\n```haskell\r\n{-# LANGUAGE OverloadedStrings #-}\r\n\r\nimport Data.List\r\nimport System.CPUTime\r\n\r\nnotWhole :: Double -> Bool\r\nnotWhole x = fromIntegral (round x) /= x\r\n\r\ncat :: Double -> Double -> Double\r\ncat l m   | m < 0  = 3.1\r\n          | l == 0  = 3.1\r\n          | notWhole l  = 3.1\r\n          | notWhole m  = 3.1\r\n          | otherwise  = read (show (round l) ++ show (round m))\r\n\r\nf :: Double -> String\r\nf x = show (round x)\r\n\r\nscoreDiv :: (Eq a, Fractional a) => a -> a -> a\r\nscoreDiv az bz  | bz == 0  = 99999\r\n                | otherwise = (/) az bz\r\n\r\nops =  [cat, (+), (-), (*), scoreDiv]\r\n```\r\nThe seven algorythms necessary to perform every possible computation are:\r\n\r\n```haskell\r\ncalc :: Double -> Double -> Double -> Double -> [(Double, Double, Double, Double)]\r\ncalc a b c d = [ (a',b',c',d') |\r\n                        [a',b',c',d'] <- nub(permutations [a,b,c,d]),\r\n                            op1 <- ops,\r\n                            op2 <- ops,\r\n                            op2 (op1 a' b') c' == 20]\r\n\r\ncalc2 :: Double -> Double -> Double -> Double -> [(Double, Double, Double, Double)]\r\ncalc2 a b c d = [ (a',b',c',d') |\r\n                        [a',b',c',d'] <- nub(permutations [a,b,c,d]),\r\n                            op1 <- ops,\r\n                            op2 <- ops,\r\n                            op2 a' (op1 b' c') == 20]\r\n\r\ncalc3 :: Double -> Double -> Double -> Double -> [(Double, Double, Double, Double)]\r\ncalc3 a b c d = [ (a',b',c',d') |\r\n                        [a',b',c',d'] <- nub(permutations [a,b,c,d]),\r\n                            op1 <- ops,\r\n                            op2 <- ops,\r\n                            op3 <- ops,\r\n                            op3 (op1 a' b') (op2 c' d') == 20]\r\n\r\ncalc4 :: Double -> Double -> Double -> Double -> [(Double, Double, Double, Double)]\r\ncalc4 a b c d = [ (a',b',c',d')  |\r\n                        [a',b',c',d'] <- nub(permutations [a,b,c,d]),\r\n                            op1 <- ops,\r\n                            op2 <- ops,\r\n                            op3 <- ops,\r\n                            op3 (op2 (op1 a' b') c') d' == 20]\r\n\r\ncalc5 a b c d = [ (a',b',c',d') |\r\n                        [a',b',c',d'] <- nub(permutations [a,b,c,d]),\r\n                            op1 <- ops,\r\n                            op2 <- ops,\r\n                            op3 <- ops,\r\n                            op3 (op2 a' (op1 b' c')) d' == 20]\r\n\r\ncalc6 a b c d = [ (a',b',c',d') |\r\n                        [a',b',c',d'] <- nub(permutations [a,b,c,d]),\r\n                            op1 <- ops,\r\n                            op2 <- ops,\r\n                            op3 <- ops,\r\n                            op3 a' (op2 (op1 b' c') d') == 20]\r\n\r\ncalc7 a b c d = [ (a',b',c',d') |\r\n                        [a',b',c',d'] <- nub(permutations [a,b,c,d]),\r\n                            op1 <- ops,\r\n                            op2 <- ops,\r\n                            op3 <- ops,\r\n                            op3 a' (op2 b' (op1 c' d')) == 20]\r\n```\r\n\r\nIt is easy to see that there are seven ways to order two or three sequential computations on four numbers. They can be represented by\r\n```javascript\r\na bc\r\nab c\r\nab cd\r\n(a bc)d\r\n(ab c)d\r\na(b cd)\r\na(bc d)\r\n```\r\nThose are the combinations used in the seven calc functions. The list comprehension works on all permutations of the order of the four numbers in receives, so c ba is covered by a bc. Next, I wanted to find out if all seven algorythms are necessary to find at least one solution, so I wrote this:\r\n\r\n```haskell\r\n{-# LANGUAGE OverloadedStrings #-}\r\n\r\nimport Data.List\r\nimport System.CPUTime\r\n\r\nnotWhole :: Double -> Bool\r\nnotWhole x = fromIntegral (round x) /= x\r\n\r\ncat :: Double -> Double -> Double\r\ncat l m   | m < 0  = 3.1\r\n          | l == 0  = 3.1\r\n          | notWhole l  = 3.1\r\n          | notWhole m  = 3.1\r\n          | otherwise  = read (show (round l) ++ show (round m))\r\n\r\nf :: Double -> String\r\nf x = show (round x)\r\n\r\nscoreDiv :: (Eq a, Fractional a) => a -> a -> a\r\nscoreDiv az bz  | bz == 0  = 99999\r\n                | otherwise = (/) az bz\r\n\r\nops =  [cat, (+), (-), (*), scoreDiv]\r\n\r\ncalc :: Double -> Double -> Double -> Double -> [(Double, Double, Double, Double)]\r\ncalc a b c d = [ (a',b',c',d') |\r\n                        [a',b',c',d'] <- nub(permutations [a,b,c,d]),\r\n                            op1 <- ops,\r\n                            op2 <- ops,\r\n                            op2 (op1 a' b') c' == 20]\r\n\r\ncalc2 :: Double -> Double -> Double -> Double -> [(Double, Double, Double, Double)]\r\ncalc2 a b c d = [ (a',b',c',d') |\r\n                        [a',b',c',d'] <- nub(permutations [a,b,c,d]),\r\n                            op1 <- ops,\r\n                            op2 <- ops,\r\n                            op2 a' (op1 b' c') == 20]\r\n\r\ncalc3 :: Double -> Double -> Double -> Double -> [(Double, Double, Double, Double)]\r\ncalc3 a b c d = [ (a',b',c',d') |\r\n                        [a',b',c',d'] <- nub(permutations [a,b,c,d]),\r\n                            op1 <- ops,\r\n                            op2 <- ops,\r\n                            op3 <- ops,\r\n                            op3 (op1 a' b') (op2 c' d') == 20]\r\n\r\ncalc4 :: Double -> Double -> Double -> Double -> [(Double, Double, Double, Double)]\r\ncalc4 a b c d = [ (a',b',c',d')  |\r\n                        [a',b',c',d'] <- nub(permutations [a,b,c,d]),\r\n                            op1 <- ops,\r\n                            op2 <- ops,\r\n                            op3 <- ops,\r\n                            op3 (op2 (op1 a' b') c') d' == 20]\r\n\r\ncalc5 a b c d = [ (a',b',c',d') |\r\n                        [a',b',c',d'] <- nub(permutations [a,b,c,d]),\r\n                            op1 <- ops,\r\n                            op2 <- ops,\r\n                            op3 <- ops,\r\n                            op3 (op2 a' (op1 b' c')) d' == 20]\r\n\r\ncalc6 a b c d = [ (a',b',c',d') |\r\n                        [a',b',c',d'] <- nub(permutations [a,b,c,d]),\r\n                            op1 <- ops,\r\n                            op2 <- ops,\r\n                            op3 <- ops,\r\n                            op3 a' (op2 (op1 b' c') d') == 20]\r\n\r\ncalc7 a b c d = [ (a',b',c',d') |\r\n                        [a',b',c',d'] <- nub(permutations [a,b,c,d]),\r\n                            op1 <- ops,\r\n                            op2 <- ops,\r\n                            op3 <- ops,\r\n                            op3 a' (op2 b' (op1 c' d')) == 20]\r\n\r\n\r\n\r\nonly_calc = [ [a, b, c, d] | a <- [1..6], b <- [1..6], c <- [1..12], d <- [1..20],\r\n                     a <= b, b <= c, c <= d,\r\n                     not (null $ calc a b c d), null $ calc2 a b c d, null $ calc3 a b c d,\r\n                     null $ calc4 a b c d, null $ calc5 a b c d, null $ calc6 a b c d,\r\n                     null $ calc7 a b c d ]\r\n\r\n\r\nonly_calc2 = [ [a, b, c, d] | a <- [1..6], b <- [1..6], c <- [1..12], d <- [1..20],\r\n                     a <= b, b <= c, c <= d,\r\n                     null $ calc a b c d, not (null $ calc2 a b c d), null $ calc3 a b c d,\r\n                     null $ calc4 a b c d, null $ calc5 a b c d, null $ calc6 a b c d,\r\n                     null $ calc7 a b c d ]\r\n\r\nonly_calc3 = [ [a, b, c, d] | a <- [1..6], b <- [1..6], c <- [1..12], d <- [1..20],\r\n                     a <= b, b <= c, c <= d,\r\n                     null $ calc a b c d, null $ calc2 a b c d, not (null $ calc3 a b c d),\r\n                     null $ calc4 a b c d, null $ calc5 a b c d, null $ calc6 a b c d,\r\n                     null $ calc7 a b c d ]\r\n\r\nonly_calc4 = [ [a, b, c, d] | a <- [1..6], b <- [1..6], c <- [1..12], d <- [1..20],\r\n                     a <= b, b <= c, c <= d,\r\n                     null $ calc a b c d, null $ calc2 a b c d, null $ calc3 a b c d,\r\n                     not (null $ calc4 a b c d), null $ calc5 a b c d, null $ calc6 a b c d,\r\n                     null $ calc7 a b c d ]\r\n\r\nonly_calc5 = [ [a, b, c, d] | a <- [1..6], b <- [1..6], c <- [1..12], d <- [1..20],\r\n                     a <= b, b <= c, c <= d,\r\n                     null $ calc a b c d, null $ calc2 a b c d, null $ calc3 a b c d,\r\n                     null $ calc4 a b c d, not (null $ calc5 a b c d), null $ calc6 a b c d,\r\n                     null $ calc7 a b c d ]\r\n\r\nonly_calc6 = [ [a, b, c, d] | a <- [1..6], b <- [1..6], c <- [1..12], d <- [1..20],\r\n                     a <= b, b <= c, c <= d,\r\n                     null $ calc a b c d, null $ calc2 a b c d, null $ calc3 a b c d,\r\n                     null $ calc4 a b c d, null $ calc5 a b c d, not (null $ calc6 a b c d),\r\n                     null $ calc7 a b c d ]\r\n\r\nonly_calc7 = [ [a, b, c, d] | a <- [1..6], b <- [1..6], c <- [1..12], d <- [1..20],\r\n                     a <= b, b <= c, c <= d,\r\n                     null $ calc a b c d, null $ calc2 a b c d, null $ calc3 a b c d,\r\n                     null $ calc4 a b c d, null $ calc5 a b c d, null $ calc6 a b c d,\r\n                     not (null $ calc7 a b c d )]\r\n\r\nmain = do\r\n    print \"*****************************___only_calc\"\r\n    t1 <- getCPUTime\r\n    mapM_ print only_calc\r\n    print \" \"\r\n\r\n    print \"*****************************___only_calc2\"\r\n    mapM_ print only_calc2\r\n    print \" \"\r\n\r\n    print \"*****************************___only_calc3\"\r\n    mapM_ print only_calc3\r\n    print \" \"\r\n\r\n    print \"*****************************___only_calc4\"\r\n    mapM_ print only_calc4\r\n    print \" \"\r\n\r\n    print \"*****************************___only_calc5\"\r\n    mapM_ print only_calc5\r\n    print \" \"\r\n\r\n    print \"*****************************___only_calc6\"\r\n    mapM_ print only_calc6\r\n    print \" \"\r\n\r\n    print \"*****************************___only_calc7\"\r\n    mapM_ print only_calc7\r\n    t2 <- getCPUTime\r\n    let t = fromIntegral (t2-t1) * 1e-12\r\n    print t\r\n    print \" \"\r\n```\r\nHere is what I got:\r\n\r\n```javascript\r\ne@e:~/b0$ ./analysis_A\r\n\"*****************************___only_calc\"\r\n[1.0,3.0,11.0,15.0]\r\n[1.0,3.0,11.0,19.0]\r\n[1.0,6.0,9.0,20.0]\r\n[1.0,6.0,10.0,20.0]\r\n[1.0,6.0,11.0,20.0]\r\n[2.0,2.0,11.0,15.0]\r\n[2.0,2.0,11.0,17.0]\r\n[3.0,3.0,3.0,13.0]\r\n[3.0,3.0,7.0,17.0]\r\n[3.0,4.0,9.0,16.0]\r\n[3.0,4.0,11.0,14.0]\r\n[4.0,4.0,6.0,17.0]\r\n[5.0,5.0,5.0,11.0]\r\n[5.0,5.0,5.0,13.0]\r\n[5.0,5.0,5.0,17.0]\r\n\" \"\r\n\"*****************************___only_calc2\"\r\n\" \"\r\n\"*****************************___only_calc3\"\r\n[1.0,1.0,1.0,11.0]\r\n[1.0,1.0,7.0,17.0]\r\n[1.0,1.0,12.0,12.0]\r\n[1.0,6.0,6.0,6.0]\r\n[1.0,6.0,9.0,9.0]\r\n[3.0,3.0,6.0,6.0]\r\n[3.0,4.0,7.0,18.0]\r\n[3.0,6.0,7.0,14.0]\r\n[5.0,5.0,6.0,17.0]\r\n[5.0,6.0,6.0,6.0]\r\n\" \"\r\n\"*****************************___only_calc4\"\r\n[1.0,1.0,4.0,11.0]\r\n[1.0,4.0,9.0,9.0]\r\n[1.0,4.0,9.0,19.0]\r\n[1.0,5.0,11.0,11.0]\r\n[1.0,6.0,6.0,12.0]\r\n[1.0,6.0,11.0,11.0]\r\n[3.0,6.0,9.0,12.0]\r\n[6.0,6.0,7.0,18.0]\r\n[6.0,6.0,9.0,14.0]\r\n\" \"\r\n\"*****************************___only_calc5\"\r\n[1.0,3.0,8.0,20.0]\r\n[3.0,3.0,10.0,17.0]\r\n[3.0,4.0,10.0,16.0]\r\n\" \"\r\n\"*****************************___only_calc6\"\r\n\" \"\r\n\"*****************************___only_calc7\"\r\n8.27113\r\n\" \"\r\n```\r\n###### This shows that there is no solution that only calc2, only calc6, or only calc7 can find. Next, I checkes all combinations of these three:\r\n\r\n```javascript\r\n{-# LANGUAGE OverloadedStrings #-}\r\n\r\nimport Data.List\r\nimport System.CPUTime\r\n\r\nnotWhole :: Double -> Bool\r\nnotWhole x = fromIntegral (round x) /= x\r\n\r\ncat :: Double -> Double -> Double\r\ncat l m   | m < 0  = 3.1\r\n          | l == 0  = 3.1\r\n          | notWhole l  = 3.1\r\n          | notWhole m  = 3.1\r\n          | otherwise  = read (show (round l) ++ show (round m))\r\n\r\nf :: Double -> String\r\nf x = show (round x)\r\n\r\nscoreDiv :: (Eq a, Fractional a) => a -> a -> a\r\nscoreDiv az bz  | bz == 0  = 99999\r\n                | otherwise = (/) az bz\r\n\r\nops =  [cat, (+), (-), (*), scoreDiv]\r\n\r\ncalc :: Double -> Double -> Double -> Double -> [(Double, Double, Double, Double)]\r\ncalc a b c d = [ (a',b',c',d') |\r\n                        [a',b',c',d'] <- nub(permutations [a,b,c,d]),\r\n                            op1 <- ops,\r\n                            op2 <- ops,\r\n                            op2 (op1 a' b') c' == 20]\r\n\r\ncalc2 :: Double -> Double -> Double -> Double -> [(Double, Double, Double, Double)]\r\ncalc2 a b c d = [ (a',b',c',d') |\r\n                        [a',b',c',d'] <- nub(permutations [a,b,c,d]),\r\n                            op1 <- ops,\r\n                            op2 <- ops,\r\n                            op2 a' (op1 b' c') == 20]\r\n\r\ncalc3 :: Double -> Double -> Double -> Double -> [(Double, Double, Double, Double)]\r\ncalc3 a b c d = [ (a',b',c',d') |\r\n                        [a',b',c',d'] <- nub(permutations [a,b,c,d]),\r\n                            op1 <- ops,\r\n                            op2 <- ops,\r\n                            op3 <- ops,\r\n                            op3 (op1 a' b') (op2 c' d') == 20]\r\n\r\ncalc4 :: Double -> Double -> Double -> Double -> [(Double, Double, Double, Double)]\r\ncalc4 a b c d = [ (a',b',c',d')  |\r\n                        [a',b',c',d'] <- nub(permutations [a,b,c,d]),\r\n                            op1 <- ops,\r\n                            op2 <- ops,\r\n                            op3 <- ops,\r\n                            op3 (op2 (op1 a' b') c') d' == 20]\r\n\r\ncalc5 a b c d = [ (a',b',c',d') |\r\n                        [a',b',c',d'] <- nub(permutations [a,b,c,d]),\r\n                            op1 <- ops,\r\n                            op2 <- ops,\r\n                            op3 <- ops,\r\n                            op3 (op2 a' (op1 b' c')) d' == 20]\r\n\r\ncalc6 a b c d = [ (a',b',c',d') |\r\n                        [a',b',c',d'] <- nub(permutations [a,b,c,d]),\r\n                            op1 <- ops,\r\n                            op2 <- ops,\r\n                            op3 <- ops,\r\n                            op3 a' (op2 (op1 b' c') d') == 20]\r\n\r\ncalc7 a b c d = [ (a',b',c',d') |\r\n                        [a',b',c',d'] <- nub(permutations [a,b,c,d]),\r\n                            op1 <- ops,\r\n                            op2 <- ops,\r\n                            op3 <- ops,\r\n                            op3 a' (op2 b' (op1 c' d')) == 20]\r\n\r\n\r\nonly_calc2_or_6 = [ [a, b, c, d] | a <- [1..6], b <- [1..6], c <- [1..12], d <- [1..20],\r\n                     a <= b, b <= c, c <= d,\r\n                     null $ calc a b c d, not (null $ calc2 a b c d), null $ calc3 a b c d,\r\n                     null $ calc4 a b c d, null $ calc5 a b c d, not (null $ calc6 a b c d),\r\n                     null $ calc7 a b c d ]\r\n\r\nonly_calc2_or_7 = [ [a, b, c, d] | a <- [1..6], b <- [1..6], c <- [1..12], d <- [1..20],\r\n                     a <= b, b <= c, c <= d,\r\n                     null $ calc a b c d, not (null $ calc2 a b c d), null $ calc3 a b c d,\r\n                     null $ calc4 a b c d, null $ calc5 a b c d, null $ calc6 a b c d,\r\n                     not (null $ calc7 a b c d) ]\r\n\r\nonly_calc6_or_7 = [ [a, b, c, d] | a <- [1..6], b <- [1..6], c <- [1..12], d <- [1..20],\r\n                     a <= b, b <= c, c <= d,\r\n                     null $ calc a b c d, null $ calc2 a b c d, null $ calc3 a b c d,\r\n                     null $ calc4 a b c d, null $ calc5 a b c d, not (null $ calc6 a b c d),\r\n                     not (null $ calc7 a b c d )]\r\n\r\n\r\nonly_calc2_or_6_or_7 = [ [a, b, c, d] | a <- [1..6], b <- [1..6], c <- [1..12], d <- [1..20],\r\n                     a <= b, b <= c, c <= d,\r\n                     null $ calc a b c d, not (null $ calc2 a b c d), null $ calc3 a b c d,\r\n                     null $ calc4 a b c d, null $ calc5 a b c d, not (null $ calc6 a b c d),\r\n                     not (null $ calc7 a b c d )]\r\n\r\nmain = do\r\n    print \"*****************************___only_calc2_or_6\"\r\n    t1 <- getCPUTime\r\n    mapM_ print only_calc2_or_6\r\n    print \" \"\r\n\r\n    print \"*****************************___only_calc2_or_7\"\r\n    mapM_ print only_calc2_or_7\r\n    print \" \"\r\n\r\n    print \"*****************************___only_calc6_or_7\"\r\n    mapM_ print only_calc6_or_7\r\n    print \" \"\r\n\r\n    print \"*****************************___only_calc2_or_6_or_7\"\r\n    mapM_ print only_calc2_or_6_or_7\r\n    t2 <- getCPUTime\r\n    let t = fromIntegral (t2-t1) * 1e-12\r\n    print t\r\n\r\n```\r\nAnd here is what I got:\r\n\r\n```javascript\r\n    e@e:~/b0$ ./analysis_B\r\n\"*****************************___only_calc2_or_6\"\r\n\" \"\r\n\"*****************************___only_calc2_or_7\"\r\n\" \"\r\n\"*****************************___only_calc6_or_7\"\r\n\" \"\r\n\"*****************************___only_calc2_or_6_or_7\"\r\n[2.0,5.0,12.0,12.0]\r\n3.385727\r\n```\r\n###### There are no rolls of the dice that can be found only by some pair of these functions, and (2,5,12,12) is the only roll that can be found by all three, but none of the algorythms (calc, calc3, calc4, and calc5) which uniquely solve some rolls. Those four along with any one of calc2, calc6, or calc7, are sufficient to find at least one solution if a roll is solvable. A corrolary is that if calc, calc2, calc3, calc4, and calc5 can't find a solution, calc6 and calc7 won't either. I tested this by removing calc6 and calc7 from impossibles.hs and renaming it impossibles2.hs. Like impossibles.hs, it found the 104 impossible rolls, only in 1.33 instead of 1.50 seconds.\r\n\r\nThe module Fm uses the seven algorythms to find solutions to random rolls or numbers entered by Score players. It massages the output into a single line of Text with solutions separated by \"\\<br>\". The browsers receive the Text as a Javascript string which, when appended to a div, displays the solutions neatly in a column.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}