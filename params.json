{"name":"Score2","tagline":"Haskell websockets up and running.","body":"**Rules of \"Score\"**\r\n\r\nFour dice are rolled. The default die are two six-sided, one twelve-sided, and one twenty-sided die. The goal is to make the number \"20\" in two or three steps using addition, subtraction, multiplication, division, and/or concatenation.\r\n\r\nIf a player calls out \"Score!\", or clicks \"SCORE\" in the computer version, he or she must quickly demonstrate how to make the number \"20\". Failure to do so loses the player one point; success gains a point. Clicking \"SCORE\" starts a countdown which currently allows 30 seconds, which is more than enough time.\r\n\r\nIf a player clicks \"IMPOSSIBLE\", a 60-second countdown begins. If no player clicks \"SCORE\" during the 60 seconds, the player who clicked \"IMPOSSIBLE\" gains one point. If a player clicks \"SCORE\" during the countdown and succeeds in making \"20\" within 30 seconds, the player who clicked \"IMPOSSIBLE\" loses two points. It is possible for the player who clicked \"IMPOSSIBLE\" to also click \"SCORE\". Making the number \"20\" within 30 seconds gains back one of the two points lost because the 60 second countdown was successfully interrupted.\r\n\r\nIn order to gain a point by making the number \"20\", a player must use a number generated by a previous computation. Those number have the color red.\r\n\r\nThe application is based on websockets messages. Chat messages go to the server and are broadcast to all participating browsers. Messages intended for game control rather than chat boxes are prefixed by C\\_#$42 where \"\\_\" is a capital letter. Messages received by browsers which are for game control, and which usually carry data, also have the C _#$42 prefixes. The flow of this application can be understood by tracing the routes of the prefixed messages.\r\n\r\nA player joins the game by entering a name in a form. Here is the Javascript form code:\r\n\r\n```Javascript\r\n    $('#join-form').submit(function () {\r\n        $('#warnings').html('');\r\n        var user = $('#user').val();\r\n        players.setPlayer(user);\r\n        ws = createWebSocket('/');\r\n        ws.onopen = function() {\r\n            ws.send(\"CC#$42\" + user);\r\n        };\r\n```\r\n\r\nThe server parses the message prefixed by CC#$42 and, if the name is in the proper format and hasn't already been taken, the server (1) adds the new user' Client tuplet, (name, 0, WebSocket), to the ServerState list, [Client], MVar; (2) broadcasts an announcement for placement in the chat section of participating browsers; broadcasts the updated state information for placement in the scoreboard section: and (3) sends the message \"CC#$42\" to the new player. The new state information is sent with the prefix \"CB#$42\", which propmts the browsers to put the updated state information where it belongs. Anytime ServerState changes in the server, a message prefixed by CB#$42 and containing the new state information is broadcast to all participating players, keeping scoreboards syncronized with the servers state MVar.\r\n\r\nThe sign-in form sends a message prefixed by CC#$42 to the server and the server sends a message consisting solely of \"CB#$42\" Here is what that little message prompts the new user's browser to do:\r\n\r\n```javascript\r\n            if(event.data.substring(0,6) == \"CC#$42\") {\r\n                players.setD(-1);\r\n                createDom();\r\n                createOperators();\r\n                createDropboxes();            \r\n                $('.drag').draggable({ revert: \"invalid\", zIndex: 2 });\r\n                $('.dragNew').draggable({ revert: \"invalid\", zIndex: 2 });\r\n                $('.drag2').draggable({ helper: \"clone\", revert: \"invalid\", zIndex: 2 });\r\n                createDrop1();\r\n                createDrop2();\r\n                $(\"#result1\").hide();\r\n                $(\"#result2\").hide();\r\n                $(\"#result3\").hide();  \r\n                $(\"#b0\").show();\r\n                $(\"#experiment\").show();\r\n                $(\"#public\").show();\r\n                $(\"#b0\").html(\"Solitaire mode. Click above to enable competition.\")\r\n                $(\"#rollA\").show();   \r\n                $(\"#a1\").show();\r\n                $('#join-section').hide();\r\n                $('#chat-section').show();\r\n                $('#users-section').show();\r\n                $(\"#messages\").show();\r\n                ws.onmessage = onMessage;\r\n                $('#message-form').submit(function () {\r\n                    var text = $('#text').val();\r\n                    ws.send(text);\r\n                    $('#text').val('');\r\n                    return false;\r\n                });\r\n```\r\nI won't discuss each item. The code is creating the most of the DOM, initalizing some Jquery-ui drag and drop functionality, and hiding three result divs which will contain newly generated numbers, one at a time, colored red to indicate they can be used to make the number \"20\" and win a point. \r\n\r\n\r\n\r\nHere is how the game state is defined:\r\n\r\n```haskell\r\ntype Name = Text\r\ntype Score = Int\r\ntype Client = (Name, Score, WS.Connection)\r\ntype ServerState = [Client]\r\n\r\nnewServerState :: ServerState\r\nnewServerState = []\r\n```\r\n\r\nThe game state is placed in an MVar as follows:\r\n\r\n```haskell\r\nmain = do\r\n    state <- newMVar newServerState\r\n... \r\n```\r\nState is modified during game play by removing state from the MVar and replacing it with the modified version. For example, the following code increases a player's score:\r\n\r\n```haskell\r\nincFunc :: Text -> Client -> Client\r\nincFunc x (a, b, c)   | x == a   = (a, b + 1, c)\r\n                      | otherwise = (a, b, c)\r\n                      \r\nupScore :: Text -> ServerState -> ServerState \r\nupScore name = map (incFunc name)\r\n```\r\nHere is the browser code dealing with the three prefixes mentioned so far:\r\n```javascript\r\nfunction onMessage(event) {\r\n    var impossibleClicker = players.getImpossibleClicker();\r\n    var player = players.getPlayer();\r\n    var scoreClicker = players.getScoreClicker();\r\n    var privateClicker = players.getPrivateClicker();\r\n    var gameArray = event.data.split(\",\");\r\n    var d2 = event.data.substring(0,6);\r\n    var d3 = event.data.substring(2,6);\r\n    var source = gameArray[1];  // Value of sender's privateClicker\r\n    var sender = gameArray[2];\r\n    var extra = gameArray[3];\r\n    var p = $(document.createElement('p')).text(event.data); \r\n    if (player === sender || privateClicker !== \"a@F$Uy&private\" &&  source !== \"a@F$Uy&private\") {\r\n        switch (d2) {\r\n            case \"CA#$42\":     // Set up the next round of play.\r\n                refresh(); \r\n                $(\"#impossibleJ\").show();\r\n                $(\"#scoreF\").show();\r\n                $(\"#info1\").html(\"\");\r\n                $(\".erase\").show();\r\n                $(\"#show\").show();\r\n                $(\"#show2\").show();\r\n                $(\"#solutions\").show();\r\n                $(\"#iutions2\").show();\r\n                $(\"#a0\").html(\"\");\r\n                var auu = gameArray[3]\r\n                var buu = gameArray[4]\r\n                var cuu = gameArray[5]\r\n                var duu = gameArray[6]\r\n                rollText = auu + \",\" + buu + \",\" + cuu + \",\" + duu + \",\" + 42;\r\n                players.setRollText(rollText) \r\n                .setD(-1);\r\n                console.log(\"Here is rollText: \" + rollText); \r\n                populate(auu,buu,cuu,duu);\r\n                $(\"#a4\").html(auu + \" &nbsp; \" + buu + \" &nbsp; \" + cuu + \" &nbsp; \" + duu);\r\n            break;\r\n\r\n            case \"CB#$42\":\r\n                $(\"#users\").html(event.data.substring(6));\r\n            break;\r\n\r\n            case \"CC#$42\":\r\n                return;\r\n            break;\r\n```\r\nMessages with the \"CB#$42\" pefix go to the socoreboard div with id \"user\", and messages prefixed by \"CC#$42\", the new player prefix, are discarded to prevent cluttering the chat message section.\r\n\r\nThe meanings and uses of the variables at the start of function \"onmessage\" will be explained later. For now, I will explain only the code which screens who gets into the the switch routine, namely:\r\n\r\n```javascript\r\nif (player === sender || privateClicker !== \"a@F$Uy&private\" &&  source !== \"a@F$Uy&private\")\r\n```\r\n\r\nThere are two modes of play in #Score#: group play and individual play. When one group player rolls the dice, all group players see the roll, but individual players do not. When an individual player rolls the dice, no other player sees it. \"player \\=\\== sender\" lets individual players in, along with one group player but that is of no consequence since the next test covers all group players. \"a@F$Uy&private\" is the default value for new players. It signifies that they are in individual play mode. If a player clicks \"GO MULTIPLAYER\", the value of privateClicker becomes the player's login name. So \"privateClicker !== 'a@F$Uy&private'\" means the player has gone public. \"sender !== 'a@F$Uy&private'\" means a group player sent the message. All group players should receive all messages sent by other group players, and the second test makes sure this happens.\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}