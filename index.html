<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">

    <title>Score2 by dschalk</title>
  </head>

  <body>

    <header>
      <div class="container">
        <h1>Score2</h1>
        <h2>Haskell websockets up and running.</h2>

        <section id="downloads">
          <a href="https://github.com/dschalk/score2/zipball/master" class="btn">Download as .zip</a>
          <a href="https://github.com/dschalk/score2/tarball/master" class="btn">Download as .tar.gz</a>
          <a href="https://github.com/dschalk/score2" class="btn btn-github"><span class="icon"></span>View on GitHub</a>
        </section>
      </div>
    </header>

    <div class="container">
      <section id="main_content">
        <h2>
<a id="the-game-of-score" class="anchor" href="#the-game-of-score" aria-hidden="true"><span class="octicon octicon-link"></span></a>The Game of Score</h2>

<h4>
<a id="an-extension-of-githubcomjaspervdjwebsockets-as-implemented-by-yesodwebwaiwai-websockets" class="anchor" href="#an-extension-of-githubcomjaspervdjwebsockets-as-implemented-by-yesodwebwaiwai-websockets" aria-hidden="true"><span class="octicon octicon-link"></span></a><em>An extension of github.com/jaspervdj/websockets as implemented by yesodweb/wai/wai-websockets</em>
</h4>

<h3>
<a id="overview" class="anchor" href="#overview" aria-hidden="true"><span class="octicon octicon-link"></span></a>Overview</h3>

<p>I started with the chat example at github.com/wai/wai-websockets. It is Jasper Van der Jeugt 's websockets adapted to the warp web server. The routine work of the chat server is receiving messages from individual browsers and broadcasting them to all participants. The server facilitates what is tantamount to peer-to-peer interactions among the browsers. It also parses sign in messages to make sure the format is correct and there are no duplicate user names. The server keeps a list of participants in an MVar, and replaces the list with an updated version whenever there is a disconnect or a sign-in.</p>

<p>I modified the participant list to include scores along with names. Whenever the list is replaced due to a score change, sign-in, or disconnect, the server sends a line of text interspersed with "<br>" and the prefix 'CB#$42'. The browsers intercept these messages and divert them away from the chat message section and into the scoreboard. There are fifteen six-character message prefixes in the format 'Cx#42' where 'x' is some capital letter. None of these go into the chat message section. They contain data and instructions for the game. Application messages are either Javascript strings or Haskell Text. Browsers split comma-separated strings into arrays and distribute the elements according to the their six-character prefixes (element '0' in the arrays).</p>

<p>It would be nice if players could compete in small groups in discreet chat rooms, or even play solitaire in their own room. Solitaire play is currently an option, but the chat messages and scoreboard are communal. I am also thinking of providing the option of changing the dice from 6, 6, 12, and 20 sided to whatever the players choose. The goal in 'Score' is to make the number '20' out of four random numbers in two or three stages using addition, subtraction, multiplication, division, and concatenation. The goal of '20' could be made adjustable along with the maximum sizes of the four random integers. Suggestions are very welcome.</p>

<p><strong>Rules of "Score"</strong></p>

<p>Four dice are rolled. The default die are two six-sided, one twelve-sided, and one twenty-sided die. As mentioned above, the goal is to make the number "20" in two or three steps using addition, subtraction, multiplication, division, and/or concatenation.</p>

<p>If a player calls out "Score!", or clicks "SCORE" in the computer version, he or she must quickly demonstrate how to make the number "20". Failure to do so loses the player one point; success gains a point. Clicking "SCORE" starts a countdown which currently allows 30 seconds, which is more than enough time.</p>

<p>If a player clicks "IMPOSSIBLE", a 60-second countdown begins. If no player clicks "SCORE" during the 60 seconds, the player who clicked "IMPOSSIBLE" gains one point. If a player clicks "SCORE" during the countdown and succeeds in making "20" within 30 seconds, the player who clicked "IMPOSSIBLE" loses two points. It is possible for the player who clicked "IMPOSSIBLE" to also click "SCORE". Making the number "20" within 30 seconds gains back one of the two points lost because the 60 second countdown was successfully interrupted.</p>

<p>In order to gain a point by making the number "20", a player must use a number generated by a previous computation. Those number have the color red.</p>

<p><strong>Initiation Stage</strong></p>

<p>Score2 is based on websockets messages. Chat messages go to the server and are broadcast to all participating browsers. Messages intended for game control rather than chat boxes are prefixed by C_#$42 where "_" is a capital letter. Messages received by browsers which are for game control, and which usually carry data, also have the C _#$42 prefixes. The flow of this application can be understood by tracing the routes of the prefixed messages.</p>

<p>A player joins the game by entering a name in a form. Here is the Javascript form code:</p>

<div class="highlight highlight-Javascript"><pre>    $(<span class="pl-s1"><span class="pl-pds">'</span>#join-form<span class="pl-pds">'</span></span>).<span class="pl-s3">submit</span>(<span class="pl-st">function</span> () {
        $(<span class="pl-s1"><span class="pl-pds">'</span>#warnings<span class="pl-pds">'</span></span>).html(<span class="pl-s1"><span class="pl-pds">'</span><span class="pl-pds">'</span></span>);
        <span class="pl-s">var</span> user <span class="pl-k">=</span> $(<span class="pl-s1"><span class="pl-pds">'</span>#user<span class="pl-pds">'</span></span>).val();
        players.setPlayer(user);
        ws <span class="pl-k">=</span> createWebSocket(<span class="pl-s1"><span class="pl-pds">'</span>/<span class="pl-pds">'</span></span>);
        <span class="pl-s3">ws</span>.<span class="pl-en">onopen</span> <span class="pl-k">=</span> <span class="pl-st">function</span>() {
            ws.<span class="pl-s3">send</span>(<span class="pl-s1"><span class="pl-pds">"</span>CC#$42<span class="pl-pds">"</span></span> <span class="pl-k">+</span> user);
        };</pre></div>

<p>The server parses the message prefixed by CC#$42 and, if the name is in the proper format and hasn't already been taken, the server (1) adds the new user' Client tuplet, (name, 0, WebSocket), to the ServerState list, [Client], MVar; (2) broadcasts an announcement for placement in the chat section of participating browsers; broadcasts the updated state information for placement in the scoreboard section: and (3) sends the message "CC#$42" to the new player. The new state information is sent with the prefix "CB#$42", which propmts the browsers to put the updated state information where it belongs. Anytime ServerState changes in the server, a message prefixed by CB#$42 and containing the new state information is broadcast to all participating players, keeping scoreboards syncronized with the servers state MVar.</p>

<p>The sign-in form sends a message prefixed by CC#$42 to the server and, if everything is in order, the server responds with</p>

<div class="highlight highlight-haskell"><pre>liftIO $ modifyMVar_ state $ \s -&gt; <span class="pl-k">do</span>
<span class="pl-k">let</span> s' = addClient client s  
<span class="pl-c1">WS</span>.sendTextData conn $ <span class="pl-c1">T</span>.pack <span class="pl-s1"><span class="pl-pds">"</span>CC#$42<span class="pl-pds">"</span></span>
broadcast (getName client <span class="pl-k">`mappend`</span> <span class="pl-s1"><span class="pl-pds">"</span> joined<span class="pl-pds">"</span></span>) s'
broadcast (<span class="pl-s1"><span class="pl-pds">"</span>CB#$42<span class="pl-pds">"</span></span> <span class="pl-k">`mappend`</span> <span class="pl-c1">T</span>.<span class="pl-s3">concat</span>(intersperse (<span class="pl-c1">T</span>.pack <span class="pl-s1"><span class="pl-pds">"</span>&lt;br&gt;<span class="pl-pds">"</span></span>) (<span class="pl-s3">map</span> tr s'))) s'
<span class="pl-s3">return</span> s'</pre></div>

<p>The message prefixed by "CB#$42" is processed in the browsers as follows:</p>

<div class="highlight highlight-javascript"><pre><span class="pl-k">case</span> <span class="pl-s1"><span class="pl-pds">"</span>CB#$42<span class="pl-pds">"</span></span><span class="pl-k">:</span>
$(<span class="pl-s1"><span class="pl-pds">"</span>#users<span class="pl-pds">"</span></span>).html(<span class="pl-s3">event</span>.<span class="pl-sc">data</span>.<span class="pl-s3">substring</span>(<span class="pl-c1">6</span>));    <span class="pl-c">// Refresh browser with server state.</span>
<span class="pl-k">break</span>;</pre></div>

<p>The browsers do not need to process the message because the server interspersed '<br>' into the state data text it sent, and the browser receives it as a string of HTML. The text 'CC#42' is received a a six-character string, prompting a response as follows:</p>

<div class="highlight highlight-javascript"><pre><span class="pl-s3">ws</span>.<span class="pl-en">onmessage</span> <span class="pl-k">=</span> <span class="pl-st">function</span>(<span class="pl-vpf">event</span>) {
  <span class="pl-k">if</span>(<span class="pl-s3">event</span>.<span class="pl-sc">data</span> <span class="pl-k">===</span> <span class="pl-s1"><span class="pl-pds">"</span>CC#$42<span class="pl-pds">"</span></span>) {
    DS_ob.d <span class="pl-k">=</span> <span class="pl-k">-</span><span class="pl-c1">1</span>;
    createDom();
    createOperators();
    createDropboxes();
    $(<span class="pl-s1"><span class="pl-pds">'</span>.drag<span class="pl-pds">'</span></span>).draggable({ revert<span class="pl-k">:</span> <span class="pl-s1"><span class="pl-pds">"</span>invalid<span class="pl-pds">"</span></span>, zIndex<span class="pl-k">:</span> <span class="pl-c1">2</span> });
    $(<span class="pl-s1"><span class="pl-pds">'</span>.dragNew<span class="pl-pds">'</span></span>).draggable({ revert<span class="pl-k">:</span> <span class="pl-s1"><span class="pl-pds">"</span>invalid<span class="pl-pds">"</span></span>, zIndex<span class="pl-k">:</span> <span class="pl-c1">2</span> });
    $(<span class="pl-s1"><span class="pl-pds">'</span>.drag2<span class="pl-pds">'</span></span>).draggable({ helper<span class="pl-k">:</span> <span class="pl-s1"><span class="pl-pds">"</span>clone<span class="pl-pds">"</span></span>, revert<span class="pl-k">:</span> <span class="pl-s1"><span class="pl-pds">"</span>invalid<span class="pl-pds">"</span></span>, zIndex<span class="pl-k">:</span> <span class="pl-c1">2</span> });
    createDrop1();
    createDrop2();
    $(<span class="pl-s1"><span class="pl-pds">"</span>#result1<span class="pl-pds">"</span></span>).hide();
    $(<span class="pl-s1"><span class="pl-pds">"</span>#result2<span class="pl-pds">"</span></span>).hide();
    $(<span class="pl-s1"><span class="pl-pds">"</span>#result3<span class="pl-pds">"</span></span>).hide();  
    $(<span class="pl-s1"><span class="pl-pds">"</span>#b0<span class="pl-pds">"</span></span>).show();
    $(<span class="pl-s1"><span class="pl-pds">"</span>#experiment<span class="pl-pds">"</span></span>).show();
    $(<span class="pl-s1"><span class="pl-pds">"</span>#public<span class="pl-pds">"</span></span>).show();
    $(<span class="pl-s1"><span class="pl-pds">"</span>#b0<span class="pl-pds">"</span></span>).html(<span class="pl-s1"><span class="pl-pds">"</span>Solitaire mode. Click above to enable competition.<span class="pl-pds">"</span></span>)
    $(<span class="pl-s1"><span class="pl-pds">"</span>#rollA<span class="pl-pds">"</span></span>).show();
    $(<span class="pl-s1"><span class="pl-pds">"</span>#a1<span class="pl-pds">"</span></span>).show();
    $(<span class="pl-s1"><span class="pl-pds">'</span>#join-section<span class="pl-pds">'</span></span>).hide();
    $(<span class="pl-s1"><span class="pl-pds">'</span>#chat-section<span class="pl-pds">'</span></span>).show();
    $(<span class="pl-s1"><span class="pl-pds">'</span>#users-section<span class="pl-pds">'</span></span>).show();
    $(<span class="pl-s1"><span class="pl-pds">"</span>#messages<span class="pl-pds">"</span></span>).show();
    $(<span class="pl-s1"><span class="pl-pds">"</span>.dropx<span class="pl-pds">"</span></span>).hide();
    $(<span class="pl-s1"><span class="pl-pds">"</span>.drop2x<span class="pl-pds">"</span></span>).hide();
    ws.onmessage <span class="pl-k">=</span> onMessage;
    $(<span class="pl-s1"><span class="pl-pds">'</span>#message-form<span class="pl-pds">'</span></span>).<span class="pl-s3">submit</span>(<span class="pl-st">function</span> () {
      <span class="pl-s">var</span> text <span class="pl-k">=</span> $(<span class="pl-s1"><span class="pl-pds">'</span>#text<span class="pl-pds">'</span></span>).val();
      ws.<span class="pl-s3">send</span>(text);
      $(<span class="pl-s1"><span class="pl-pds">'</span>#text<span class="pl-pds">'</span></span>).val(<span class="pl-s1"><span class="pl-pds">'</span><span class="pl-pds">'</span></span>);
      <span class="pl-k">return</span> <span class="pl-c1">false</span>;
    });
  } <span class="pl-k">else</span> {
    <span class="pl-en">console</span><span class="pl-s3">.log</span>(<span class="pl-s1"><span class="pl-pds">"</span>What?<span class="pl-pds">"</span></span>);
    $(<span class="pl-s1"><span class="pl-pds">'</span>#warnings<span class="pl-pds">'</span></span>).append(<span class="pl-s3">event</span>.<span class="pl-sc">data</span>);
    ws.<span class="pl-s3">close</span>();
  }
};</pre></div>

<p>After sign-in, this block of code probably gets garbage-collected. ws.onmessage = onMessage kicks in, and in onMessage we have the code:</p>

<div class="highlight highlight-javascript"><pre><span class="pl-k">case</span> <span class="pl-s1"><span class="pl-pds">"</span>CC#$42<span class="pl-pds">"</span></span><span class="pl-k">:</span>
<span class="pl-c">// Prevents new player login data from defaulting to a chat message.</span>
<span class="pl-k">break</span>;</pre></div>

<p>This creates a dead end for messages prefixed by 'CC#42'.</p>

<p><strong>State And Its Containing MVar</strong></p>

<p>Here is how the game state is defined:</p>

<div class="highlight highlight-haskell"><pre><span class="pl-k">type</span> <span class="pl-c1">Name</span> = <span class="pl-c1">Text</span>
<span class="pl-k">type</span> <span class="pl-c1">Score</span> = <span class="pl-c1">Int</span>
<span class="pl-k">type</span> <span class="pl-c1">Client</span> = (<span class="pl-c1">Name</span>, <span class="pl-c1">Score</span>, <span class="pl-c1">WS</span>.<span class="pl-c1">Connection</span>)
<span class="pl-k">type</span> <span class="pl-c1">ServerState</span> = [<span class="pl-c1">Client</span>]

<span class="pl-en">newServerState</span> <span class="pl-k">::</span> <span class="pl-st">ServerState</span>
newServerState = <span class="pl-c1">[]</span></pre></div>

<p>The game state is placed in an MVar as follows:</p>

<div class="highlight highlight-haskell"><pre>main = <span class="pl-k">do</span>
    state &lt;- newMVar newServerState
...</pre></div>

<p>State is modified during game play by removing state from the MVar and replacing it with the modified version. For example, the following code increases a player's score:</p>

<div class="highlight highlight-haskell"><pre><span class="pl-en">incFunc</span> <span class="pl-k">::</span> <span class="pl-st">Text</span> <span class="pl-k">-&gt;</span> <span class="pl-st">Client</span> <span class="pl-k">-&gt;</span> <span class="pl-st">Client</span>
incFunc x (a, b, c)   | x == a   = (a, b + <span class="pl-c1">1</span>, c)
                      | <span class="pl-s3">otherwise</span> = (a, b, c)

<span class="pl-en">upScore</span> <span class="pl-k">::</span> <span class="pl-st">Text</span> <span class="pl-k">-&gt;</span> <span class="pl-st">ServerState</span> <span class="pl-k">-&gt;</span> <span class="pl-st">ServerState</span>
upScore name = <span class="pl-s3">map</span> (incFunc name)

<span class="pl-k">else</span> <span class="pl-k">if</span> <span class="pl-s1"><span class="pl-pds">"</span>CG#$42<span class="pl-pds">"</span></span> `<span class="pl-c1">T</span>.isPrefixOf` msg
<span class="pl-k">then</span>
mask_ $ <span class="pl-k">do</span>  
old &lt;- takeMVar state
<span class="pl-k">let</span> new = upScore sender old
putMVar state new
broadcast msg new
broadcast (<span class="pl-s1"><span class="pl-pds">"</span>CB#$42<span class="pl-pds">"</span></span> <span class="pl-k">`mappend`</span> <span class="pl-c1">T</span>.<span class="pl-s3">concat</span> (intersperse <span class="pl-s1"><span class="pl-pds">"</span>&lt;br&gt;<span class="pl-pds">"</span></span> (<span class="pl-s3">map</span> tr new))) new</pre></div>

<p>The 'msg' being broadcast is just the unaltered message that was received. The 'CB#$42' prefixed message updates the browser scoreboards.</p>

<p><strong>Screening Massages Arriving At The Browsers</strong></p>

<p>The first stage of processing messages coming into the browsers is as follows:</p>

<div class="highlight highlight-javascript"><pre><span class="pl-st">function</span> <span class="pl-en">onMessage</span>(<span class="pl-vpf">event</span>) {
  <span class="pl-s">var</span> game <span class="pl-k">=</span> DS_ob.game;
  <span class="pl-s">var</span> impX <span class="pl-k">=</span> DS_ob.impossibleClicker;
  <span class="pl-s">var</span> plX <span class="pl-k">=</span> DS_ob.player;
  <span class="pl-s">var</span> scX <span class="pl-k">=</span> DS_ob.scoreClicker;
  <span class="pl-s">var</span> prX <span class="pl-k">=</span> DS_ob.privateClicker;
  <span class="pl-s">var</span> gameArray <span class="pl-k">=</span> <span class="pl-s3">event</span>.<span class="pl-sc">data</span>.<span class="pl-s3">split</span>(<span class="pl-s1"><span class="pl-pds">"</span>,<span class="pl-pds">"</span></span>);
  <span class="pl-s">var</span> d2 <span class="pl-k">=</span> <span class="pl-s3">event</span>.<span class="pl-sc">data</span>.<span class="pl-s3">substring</span>(<span class="pl-c1">0</span>,<span class="pl-c1">6</span>);
  <span class="pl-s">var</span> d3 <span class="pl-k">=</span> <span class="pl-s3">event</span>.<span class="pl-sc">data</span>.<span class="pl-s3">substring</span>(<span class="pl-c1">2</span>,<span class="pl-c1">6</span>);
  <span class="pl-s">var</span> sourceStatus <span class="pl-k">=</span> gameArray[<span class="pl-c1">1</span>];  <span class="pl-c">// Value of sender's privateClicker</span>
  <span class="pl-s">var</span> sender <span class="pl-k">=</span> gameArray[<span class="pl-c1">2</span>];
  <span class="pl-s">var</span> extra <span class="pl-k">=</span> gameArray[<span class="pl-c1">3</span>];
  <span class="pl-s">var</span> ext4<span class="pl-k">=</span> gameArray[<span class="pl-c1">4</span>];
  <span class="pl-s">var</span> ext5 <span class="pl-k">=</span> gameArray[<span class="pl-c1">5</span>];
  <span class="pl-s">var</span> ext6 <span class="pl-k">=</span> gameArray[<span class="pl-c1">6</span>];
  <span class="pl-s">var</span> ext7 <span class="pl-k">=</span> gameArray[<span class="pl-c1">7</span>];
  <span class="pl-s">var</span> ext8 <span class="pl-k">=</span> gameArray[<span class="pl-c1">8</span>];
  <span class="pl-s">var</span> p <span class="pl-k">=</span> $(<span class="pl-s3">document</span>.<span class="pl-s3">createElement</span>(<span class="pl-s1"><span class="pl-pds">'</span>p<span class="pl-pds">'</span></span>)).<span class="pl-sc">text</span>(<span class="pl-s3">event</span>.<span class="pl-sc">data</span>);
  <span class="pl-k">if</span> (plX <span class="pl-k">===</span> sender <span class="pl-k">||</span> prX <span class="pl-k">!==</span> <span class="pl-s1"><span class="pl-pds">"</span>a@F$Uy&amp;private<span class="pl-pds">"</span></span> <span class="pl-k">&amp;&amp;</span>  sourceStatus <span class="pl-k">!==</span> <span class="pl-s1"><span class="pl-pds">"</span>a@F$Uy&amp;private<span class="pl-pds">"</span></span>) {
    <span class="pl-k">switch</span> (d2) {
</pre></div>

<p>Other than chat messages and the scoreboard update, each message is sent to the server begining with a six-digit prefix, the status (solitaire or group play) of the sender, and the name of the sender, all separated by commas. The server broadcasts messages with these same three preliminary items intact so, after splitting into 'gameArray', gameArray[0] is the six-character prefix, gameArray[1] is the sender's status, and gameArray[2] is the sender's name. The game status, prefixed by 'CB#$42', is sent without commas so instead of d2 = gamearray[0], we have 'd2 = event.data.substring(0,6)'. The test in the 'if' statement returns 'true' if the sender is the receiver of the prefix, or if the sender and receiver are both involved in group play. 'a@F$Uy&amp;private' is the default status; i.e., private. When a player opts for group play, status is set equal to the player's name. This information is kept in the object 'DS_ob'.</p>

<p><em>To be continued</em></p>
      </section>
    </div>

    
  </body>
</html>